package mp4_test

import (
	"bytes"
	"os"
	"testing"

	"github.com/Eyevinn/mp4ff/bits"
	"github.com/Eyevinn/mp4ff/mp4"
)

// TestDecodeHeaderSRI tests DecodeHeaderSR with sufficient and insufficient bytes
func TestDecodeHeaderSRInsufficientBytes(t *testing.T) {
	tests := []struct {
		name    string
		data    []byte
		wantErr bool
	}{
		{
			name:    "7 bytes (one less than boxHeaderSize)",
			data:    make([]byte, 7),
			wantErr: true,
		},
		{
			name:    "8 bytes (exactly boxHeaderSize)",
			data:    []byte{0x00, 0x00, 0x00, 0x10, 't', 'e', 's', 't'}, // size=16, type="test"
			wantErr: false,
		},
		{
			name:    "extended size with insufficient bytes",
			data:    []byte{0x00, 0x00, 0x00, 0x01, 't', 'e', 's', 't', 0x00, 0x00, 0x00},
			wantErr: true,
		},
		{
			name:    "extended size with sufficient bytes",
			data:    []byte{0x00, 0x00, 0x00, 0x01, 't', 'e', 's', 't', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20},
			wantErr: false,
		},
		{
			name:    "zero size not supported",
			data:    []byte{0x00, 0x00, 0x00, 0x00, 't', 'e', 's', 't'},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			sr := bits.NewFixedSliceReader(tt.data)
			_, err := mp4.DecodeHeaderSR(sr)
			if (err != nil) != tt.wantErr {
				t.Errorf("DecodeHeaderSR() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

// Test decode + encode file with slice reader and writer
func TestDecodeEncodeSRW(t *testing.T) {
	testFiles := []string{
		"testdata/1.m4s",
		"testdata/prog_8s_enc_dashinit.mp4",
		"testdata/prog_8s.mp4",
	}
	for _, testFile := range testFiles {

		inData, err := os.ReadFile(testFile)
		if err != nil {
			t.Error(err)
		}
		sr := bits.NewFixedSliceReader(inData)
		decFile, err := mp4.DecodeFileSR(sr)
		if err != nil {
			t.Error(err)
		}
		decFile.FragEncMode = mp4.EncModeBoxTree
		sw := bits.NewFixedSliceWriter(len(inData))
		err = decFile.EncodeSW(sw)
		if err != nil {
			t.Error(err)
		}
		if !bytes.Equal(inData, sw.Bytes()) {
			t.Errorf("mismatch for testfile %s. Generated bytes differ from input", testFile)
		}
	}
}
